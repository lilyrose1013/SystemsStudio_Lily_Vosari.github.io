<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Project 1 Self as Systems</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Send+Flowers&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
  </head>

  <body>
    <header class="site-header">
      <nav class="navbar">
        <div class="brand">Systems Studio</div>
        <ul class="nav-links">
          <li><a href="index.html">Home</a></li>
          <li><a href="Project_1_Self.html" class="active">Project 1 Self as Systems</a></li>
        </ul>
      </nav>
    </header>

    <main class="main-content">
      <div class="canvas-wrap" aria-label="Canvas with overlay popup">
        <canvas id="mainCanvas" width="800" height="800"></canvas>

        <div class="backdrop" aria-hidden="true"></div>

        <div class="popup" role="dialog" aria-modal="false" aria-label="Centered popup">
        </div>
      </div>
    </main>

    <footer class="site-footer">
      <p class="sr-only">Footer placeholder</p>
    </footer>

    <script>
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas && canvas.getContext ? canvas.getContext('2d') : null;

      // Provided text (kept as given by user)
      const QUOTE = `" My cherries (Hey) and wine, rosemary and thyme
And all of my peaches are ruined"- Lana Del Rey, Cherry`;

      // Draw everything after fonts are ready to prevent layout shift
      (document.fonts ? document.fonts.ready : Promise.resolve()).then(() => {
        if (!ctx) return;

        // Background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Canvas boundary
        ctx.strokeStyle = '#9ca3af';
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);

        // Centered 400x400 gray box
        const BOX_SIZE = 400;
        const boxX = (canvas.width - BOX_SIZE) / 2;
        const boxY = (canvas.height - BOX_SIZE) / 2;

        ctx.fillStyle = '#9ca3af';
        ctx.fillRect(boxX, boxY, BOX_SIZE, BOX_SIZE);

        ctx.lineWidth = 2;
        ctx.strokeStyle = '#6b7280';
        ctx.strokeRect(boxX + 1, boxY + 1, BOX_SIZE - 2, BOX_SIZE - 2);

        // --- Centered red text inside the box ---

        // Text style
        const fontSize = 26; // adjust as needed
        ctx.font = `${fontSize}px "Send Flowers", cursive`;
        ctx.fillStyle = '#ef4444'; // red
        ctx.textAlign = 'center';
        ctx.textBaseline = 'alphabetic'; // weâ€™ll compute exact y

        // Wrap text to fit inside the box with padding
        const padding = 28;
        const maxWidth = BOX_SIZE - padding * 2;
        const lineHeight = Math.round(fontSize * 1.35);

        const lines = wrapText(ctx, QUOTE, maxWidth);

        // Vertically center block
        const blockHeight = lines.length * lineHeight;
        let startX = boxX + BOX_SIZE / 2;
        let startY = boxY + (BOX_SIZE - blockHeight) / 2 + fontSize; // baseline compensation

        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], startX, startY + i * lineHeight);
        }
      });

      // Word-wrap helper with explicit newline support
      function wrapText(ctx, text, maxWidth) {
        const result = [];
        const paragraphs = String(text).split(/\n/);

        for (const para of paragraphs) {
          const words = para.split(/\s+/);
          let line = '';

          for (const word of words) {
            const testLine = line ? line + ' ' + word : word;
            if (ctx.measureText(testLine).width <= maxWidth) {
              line = testLine;
            } else {
              if (line) result.push(line);
              // If a single word is longer than maxWidth, force-break it
              if (ctx.measureText(word).width > maxWidth) {
                let chunk = '';
                for (const ch of word) {
                  const test = chunk + ch;
                  if (ctx.measureText(test).width <= maxWidth) {
                    chunk = test;
                  } else {
                    if (chunk) result.push(chunk);
                    chunk = ch;
                  }
                }
                line = chunk;
              } else {
                line = word;
              }
            }
          }
          if (line) result.push(line);
        }

        return result;
      }
    </script>
  </body>
</html>
